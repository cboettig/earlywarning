`ro warning=FALSE, message=FALSE, comment=NA, tidy=FALSE, cache=TRUE, verbose=TRUE, cache.path="2012-05-15-nullfallacy/" or`

# Code for Prosecutors Fallacy 

``` {r prelim, cache=FALSE, echo=FALSE}
require(knitcitations)
````

This code is written in the `R` language for statistical computing.  
Population dynamics are simulated using the `populationdynamics` package
`r citep(citation("populationdynamics"))` for exact simulations of 
discrete birth-death processes in continuous time using the Gillespie
agorithm `r citep("10.1021/j100540a008")`.  Early warning signals
of variance and autocorrelation, as well as the model-based estimate
of `r citet("10.1098/rsif.2012.0125") are estimated using the 
`earlywarning` package `r citep(citation("earlywarning")`.  These
packages can be installed from Github using the `devtools` R package

```r
library(devtools)
install_github("populationdynamics", "cboettig")
install_github("earlywarning", "cboettig")
```

In the examples of this manuscript, the population dynamics are given by

<div>
\begin{align}
  \frac{dP(n,t)}{dt} &= b_{n-1} P(n-1,t) + d_{n+1}P(n+1,t) - (b_n+d_n) P(n,t)  \label{master}, \\
    b_n &= \frac{e K n^2}{n^2 + h^2}, \\
    d_n &= e n + a,
\end{align}
</div>

which is provided by the `saddle_node_ibm` model in `populationdynamics`. 

For each of the warning signal statistics in question, 
we need to generate the distibution over all replicates
and then over replicates which have been selected conditional 
on having experienced a crash.  

We begin by running the simulation of the process for all replicates.  
First, we load the required libraries.  
 
``` {r libraries}
library(populationdynamics)
library(earlywarning)
library(reshape2)		# data manipulation
library(data.table)	# data manipulation
library(ggplot2)		# graphics
library(snowfall)		# parallel
````


Then we fix a set of paramaters we will use for the simulation function,

``` {r simdatf_null}
select_crashes <- function(n){
	T<- 5000
	n_pts <- n
	pars = c(Xo = 500, e = 0.5, a = 180, K = 1000, h = 200,
    i = 0, Da = 0, Dt = 0, p = 2)
	sn <- saddle_node_ibm(pars, times=seq(0,T, length=n_pts), reps=500)
	d <- dim(sn$x1)
	crashed <- which(sn$x1[d[1],]==0)
	sn$x1[1:501,]
}
````

To take advantage of parallelization, we loop over this function a set
number of times.  The `snowfall` library provides the parallelization
of the `lapply` loop.  A few extra commands format the data into a table
with columns of times, replicate id number, and population value at the
given time.

``` {r simdat_null}
sfInit(parallel=TRUE, cpu=12)
sfLibrary(populationdynamics)
sfExportAll()
examples <-  sfLapply(1:24, function(i) select_crashes(50000))
dat <- melt(as.matrix(as.data.frame(examples, check.names=FALSE)))
dat <- melt(examples)
names(dat) = c("time", "reps", "value")
levels(dat$reps) <- 1:length(levels(dat$reps)) 
````

Zoom in on the relevant area of data near the crash

``` {r subsetdata_null }
require(plyr)
nullzoom <- ddply(dat, "reps", function(X){
    data.frame(time=X$time, value=X$value)
    })
save(list="nullzoom", file="nullzoom.rda")
````

Compute model-based warning signals on all each of these.  

``` {r summarize_null}
dt <- data.table(nullzoom)
var <- dt[, warningtrend(data.frame(time=time, value=value), window_var), by=reps]$V1
acor <- dt[, warningtrend(data.frame(time=time, value=value), window_autocorr), by=reps]$V1
dat <- melt(data.frame(var=var, acor=acor))
ggplot(dat) + geom_density(aes(value), bw=0.2) + facet_wrap(~variable) + xlim(c(-1, 1))
````


